/*
 * naan_init.nlg
 * Naanide
 *
 * Loaded automatically to initialize the main Naanide browser thread.
 *
 * column positioning:                          //                          //                      !
 *
 * Copyright (c) 2017-2025 by Richard C. Zulch
 *
 */

loglevel(3);
chns("Start");

defineExt("nlg", true);                                                     // our code extension


/*
 * Debugging & Tools
 *
 */

if !module.owner.list.running.components.debugnub {
    require("naanlib:frameworks/common/repltools.nlg").ImportReplTools()
    require("naanlib:frameworks/running/debugnub.nlg").DebugNub()
    require("naanlib:frameworks/running/taskexec.nlg").TaskExecutor()
};


/*
 * loadSecret
 * storeSecret
 *
 *     We have to track the secret API-access guid separately because the main persistence is
 * version-dependent, and if we reload we might be changing versions.
 *
 */

function loadSecret() {
    try {
        js.w.localStorage.getItem("Nide_Guid")
    } catch {
        ErrorDebuglog("loadSecret exception", exception)
        false
    }
};

function storeSecret(guid) {
    try {
        js.w.localStorage.removeItem("Nide_Guid")
        js.w.localStorage.setItem("Nide_Guid", guid)
    } catch {
        ErrorDebuglog("storeSecret exception", exception)
        false
    }
};


/*
 * loadSession
 * saveSession
 *
 *     Persistent access for session data without leakage. This ensures that any data element stored
 * with sessionSave is only saved in the current session and does not "leak" into the saved state
 * for all sessions.
 *
 */

appSession = false;
bcSession = false;

function saveSession() {
    try {
        js.w.sessionStorage.removeItem("Nide_Session")
        js.w.sessionStorage.setItem("Nide_Session", js.w.JSON.stringify(appSession))
        true
    } catch {
        ErrorDebuglog("saveSession exception", exception)
        false
    }
};

function loadSession(local key, data) {
    try {
        appSession = new(nonce)                                             // nonce is not persisted
        for `(key, data) in new(js.w.JSON.parse(js.w.sessionStorage.getItem("Nide_Session")))
            appSession[key] = data
        appSession.saveSession = saveSession
        dupeSessionCheck()
    } catch {
        ErrorDebuglog("loadSession exception", exception)
        false
    }
};


/*
 * dupeSessionCheck
 *
 *     Check for a duplicate session with another tab, which is annoying. This uses a broadcast
 * channel to see if an existing tab is using our prospective new instanceID. If so then we clear
 * the instanceID from our session storage and reload. We have to reload the page because we don't
 * know how long it will take for all the responders to broadcast back to us. Could easily be a
 * second with Chrome due to throttling, but definitely slower than our first use of the id.
 *
 */

function dupeSessionCheck() {
    if !bcSession {
        bcSession = xnew(js.w.BroadcastChannel, "NaanIDE-instanceID-check")
        bcSession.addEventListener("message", function(event, local msg) {
            msg = new(event.data)
            if msg.op == "check" && msg.id == appSession.instanceID
                bcSession.postMessage({                                     // we were duplicated
                    op: "duplicate"
                    id: appSession.instanceID
                })
            else if msg.op == "duplicate" && msg.id == appSession.instanceID {
                appSession.instanceID = undefined
                saveSession()
                js.w.location.reload()
            }
        })
    }
    if appSession.instanceID
        bcSession.postMessage({
            op: "check"
            id: appSession.instanceID
        })
};


/*
 * loadNide
 *
 *     Load Naanide into the browser, whether for the first time or after reload.
 *
 */

serverurl = js.w.location.protocol.concat("//", js.w.location.host);
authState = { };

function loadNide(local hostpath, baseurl, guid, bapi, bide, bui) {
    hostpath = js.w.location.origin.concat(js.r("path").dirname(js.w.location.pathname))
    if hostpath.slice(-1) != "/"
        hostpath = hostpath.concat("/")                                     // must end in "/"
    baseurl = js.w.location.href.split(RegExp("[?#]"))[0]                   // URL without variables or hashes
    guid = xnew(js.w.URL, js.w.location.href).searchParams.get("guid")
    if guid {                                                               // remove the GUID from the visible URL
        storeSecret(guid)
        authState.guid = guid
        js.w.history.replaceState(authState, "", baseurl)
    }
    else
        guid = loadSecret()                                                 // see if we have stored the GUID
    loadSession()
    bapi = require("naanlib:frameworks/client/apiclient.nlg").APIClient({
        url: hostpath
        guid: guid
        instanceID: appSession.instanceID
    })
    appSession.instanceID = bapi.instanceID
    bide = require("nide/nideClient/nideClient.nlg").NideController(bapi, appSession)
    bui = require("nide/nideUI/nideUI.nlg").MakeNideUI(bide)
    bide.setUI(bui)
    saveSession()
} ();

module.postload = loadNide;                                                 // called again after reload
